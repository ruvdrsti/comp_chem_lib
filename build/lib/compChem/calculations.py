def angleCalculator(atoms , molecule):
    """
    Caculates the bond angle between three atoms

    input:
    atoms: tuple containing three numbers corresponding to atoms
    molecule: a tuple as created by the readData function 

    output:
    the bond angle between the three atoms if relevant, in radians

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    if distanceMatrix[atoms[0]][atoms[1]] >= 4 or distanceMatrix[atoms[1]][atoms[2]] >= 4:
        return "too far"
    dot_product = np.dot(UnitVectorCalculator(atoms[1], atoms[0], molecule), UnitVectorCalculator(atoms[1], atoms[2], molecule))
    return np.arccos(dot_product)


def UnitVectorCalculator(atom1, atom2, molecule):
    """
    Calculates the unit vector between two atoms

    input:
    atom*: 2 numbers, associated with atoms in a molecule
    molecule: a tuple as created by the readData function

    output:
    a (1,3) array representing the unit vector in cartesian space
    """
    vector1 = molecule[1][atom1]
    vector2 = molecule[1][atom2]
    lenght = distanceMatrix[atom1, atom2]
    return (vector2 - vector1)/lenght


from itertools import combinations
def allBondAngles(molecule):
    """
    Calculates all relevan bond angles for given molecule

    input:
    molecule: a tuple as generated by the readData function

    output:
    a dictionary of all relevant bond angles in the molecule (degrees)

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    atoms = np.arange(len(molecule[0]))
    combs = combinations(atoms, 3)
    angles_dict = {}
    for combination in combs:
        angle = angleCalculator(combination, molecule)
        if angle != "too far":
            angles_dict[combination] = angle*180/np.pi
    return angles_dict