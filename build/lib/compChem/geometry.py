from scipy.spatial.distance import cdist
from compChem import data_input
import numpy as np
from itertools import combinations
from itertools import permutations
atomicmass_dict = {8:15.994, 6:12.0107, 1:1.0079}
class molecule:
    def __init__(self, input_file):
        """
        sets up the object

        input:
        input_file: fath to a file containing the molecular coords
        """
        self.atoms, self.coords = data_input.readData(input_file)
        self.distanceMatrix = cdist(self.coords, self.coords)


    def UnitVectorCalculator(self, atom1, atom2, molecule):
        """
        Calculates the unit vector between two atoms

        input:
        atom*: 2 numbers, associated with atoms in a molecule
        molecule: a tuple as created by the readData function

        output:
        a (1,3) array representing the unit vector in cartesian space
        """
        vector1 = self.coords[atom1]
        vector2 = self.coords[atom2]
        lenght = self.distanceMatrix[atom1, atom2]
        return (vector2 - vector1)/lenght

    
    def angleCalculator(self, atoms , molecule):
        """
        Caculates the bond angle between three atoms

        input:
        atoms: tuple containing three numbers corresponding to atoms
        molecule: a tuple as created by the readData function 

        output:
        the bond angle between the three atoms if relevant, in radians

        note:
        the distanceMatrix is a global variable. It needs to be set before the function can be used
        """
        if self.distanceMatrix[atoms[0]][atoms[1]] >= 4 or self.distanceMatrix[atoms[1]][atoms[2]] >= 4:
            return "too far"
        dot_product = np.dot(self.UnitVectorCalculator(atoms[1], atoms[0], molecule), self.UnitVectorCalculator(atoms[1], atoms[2], molecule))
        return np.arccos(dot_product)
    
    
    def allBondAngles(self):
        """
        Calculates all relevan bond angles for given molecule

        input:
        molecule: a tuple as generated by the readData function

        output:
        a dictionary of all relevant bond angles in the molecule (degrees)

        note:
        the distanceMatrix is a global variable. It needs to be set before the function can be used
        """
        atoms = np.arange(len(self.atoms))
        combs = combinations(atoms, 3)
        angles_dict = {}
        for combination in combs:
            angle = self.angleCalculator(combination, molecule)
            if angle != "too far":
                angles_dict[combination] = angle*180/np.pi
        return angles_dict


    
    def oopAnglesCalc(self, atoms, molecule):
        """
        Calculates the out-of-plane angle between 4 atoms

        input:
        atoms: tuple containing 4 numbers representing atoms
        molecule: a tuple generated from the readData function
        distanceMatrix: a matrix holding the interatomic distances

        output:
        the out-of-plan-angle between the atoms

        note:
        the distanceMatrix is a global variable. It needs to be set before the function can be used
        """
        if self.distanceMatrix[atoms[0]][atoms[3]] >= 4 or  self.distanceMatrix[atoms[1]][atoms[3]] >= 4 or self.distanceMatrix[atoms[2]][atoms[3]] >= 4:
            return "too far"
        # define part by part, for clarity
        cross_product = np.cross(self.UnitVectorCalculator(atoms[3], atoms[1], molecule), self.UnitVectorCalculator(atoms[3], atoms[2], molecule))
        
        dot_product = np.dot(cross_product, self.UnitVectorCalculator(atoms[3], atoms[0], molecule))

        bond_angle = self.angleCalculator((atoms[1], atoms[3], atoms[2]), molecule)

        return np.arcsin(dot_product/np.sin(bond_angle))



    def allOopAngles(self):
        """
        Calculates all oop angles for a given molecule

        input:
        molecule: a tuple as generated by the readData function
        distanceMatrix: a matrix holding the interatomic distances

        output:
        a dictionary containing all relevant oop angles (degrees)
        """
        atoms = np.arange(len(self.atoms))
        perm = permutations(atoms, 4)
        angles_dict = {}
        for permutation in perm:
            angle = self.oopAnglesCalc(permutation, molecule)
            if angle != "too far":
                # because oop angles fulfill a symmetry
                if (permutation[0], permutation[2], permutation[1], permutation[3]) not in angles_dict:
                    angles_dict[permutation] = angle*180/np.pi
        return angles_dict


    def torsionAngleCalc(atoms, molecule):
        """ 
        Calculates the torsional angle between 4 atoms

        input:
        atoms: a tuple of numbers representing atoms
        molecule: a tuple as generated by the dataReader function
        distanceMatrix: a matrix that holds the interatomic distances

        output:
        the torsion angle

        note:
        the distanceMatrix is a global variable. It needs to be set before the function can be used
        """
        if self.distanceMatrix[atoms[0]][atoms[1]] >= 4 or  self.distanceMatrix[atoms[1]][atoms[2]] >= 4 or self.distanceMatrix[atoms[2]][atoms[3]] >= 4:
            return "too far"
        # define part by part, for clarity
        cross_product1 = np.cross(self.UnitVectorCalculator(atoms[0], atoms[1], molecule), self.UnitVectorCalculator(atoms[1], atoms[2], molecule))
        
        cross_product2 = np.cross(self.UnitVectorCalculator(atoms[1], atoms[2], molecule), self.UnitVectorCalculator(atoms[2], atoms[3], molecule))

        bond_angle1 = self.angleCalculator(atoms[:-1], molecule)

        bond_angle2 = self.angleCalculator(atoms[1:], molecule)
        # we need to limit the amount of decimals here
        torsion_angle = np.arccos(np.around(np.dot(cross_product1, cross_product2)/(np.sin(bond_angle1)*np.sin(bond_angle2)), 4))
        return torsion_angle


    def allTorsionAnlges(self):
        """
        Calculates all the torsion angles in a given molecule

        input:
        molecule: a tuple as generated in the dataReader function
        distanceMatrix: a matrix the interatomic distances

        output:
        a dictionary containing all torsion angles (degrees)
        """
        atoms = np.arange(len(self.atoms))
        combs = combinations(atoms, 4)
        angles_dict = {}
        for combination in combs:
            angle = self.torsionAngleCalc(combination, molecule)
            if angle != "too far":
                angles_dict[combination] = angle*180/np.pi
        return angles_dict



    def centerOfMassDeterminator(self):
        """
        Calculates the position of the center of mass

        input:
        molecule: tuple as generated by the readData function

        output:
        the position of the center of mass
        """
        atomic_weight = np.array([atomicmass_dict[atom] for atom in self.atoms])
        multiplied_coords = atomic_weight*self.coords.T
        return np.sum(multiplied_coords, axis =1)/np.sum(atomic_weight)


    def tensorCalculator(self):
        """
        calculates the moment of inertia tensor for the given molecule

        input:
        molecule: a tuple as generated by the readData function

        output:
        the moment of inertia tensor
        """
        atomic_weigth = np.array([atomicmass_dict[atom] for atom in self.atoms])
        molecule_center_distance = self.coords - self.centerOfMassDeterminator()
        
        # initiate matrix
        
        inertia_tensor = np.zeros((3,3))
        
        # Since we will always work in 3D space, this nested loop will not become ineficcient with larger data 
        for i in range(3):
            for j in range(3):
                if i != j:
                    inertia_tensor[i, j] += np.sum(atomic_weigth*(molecule_center_distance[:, i]*molecule_center_distance[:, j]))
                else:
                    work_with = np.delete(molecule_center_distance, i, axis=1)
                    inertia_tensor[i, i] += np.sum(atomic_weigth*work_with.T**2)

        return inertia_tensor