import numpy as np
def angleCalculator(atoms , molecule):
    """
    Caculates the bond angle between three atoms

    input:
    atoms: tuple containing three numbers corresponding to atoms
    molecule: a tuple as created by the readData function 

    output:
    the bond angle between the three atoms if relevant, in radians

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    if self.distanceMatrix[atoms[0]][atoms[1]] >= 4 or self.distanceMatrix[atoms[1]][atoms[2]] >= 4:
        return "too far"
    dot_product = np.dot(UnitVectorCalculator(atoms[1], atoms[0], molecule), UnitVectorCalculator(atoms[1], atoms[2], molecule))
    return np.arccos(dot_product)


def UnitVectorCalculator(atom1, atom2, molecule):
    """
    Calculates the unit vector between two atoms

    input:
    atom*: 2 numbers, associated with atoms in a molecule
    molecule: a tuple as created by the readData function

    output:
    a (1,3) array representing the unit vector in cartesian space
    """
    vector1 = molecule[1][atom1]
    vector2 = molecule[1][atom2]
    lenght = self.distanceMatrix[atom1, atom2]
    return (vector2 - vector1)/lenght


from itertools import combinations
def allBondAngles(molecule):
    """
    Calculates all relevan bond angles for given molecule

    input:
    molecule: a tuple as generated by the readData function

    output:
    a dictionary of all relevant bond angles in the molecule (degrees)

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    atoms = np.arange(len(molecule[0]))
    combs = combinations(atoms, 3)
    angles_dict = {}
    for combination in combs:
        angle = angleCalculator(combination, molecule)
        if angle != "too far":
            angles_dict[combination] = angle*180/np.pi
    return angles_dict


def oopAnglesCalc(atoms, molecule):
    """
    Calculates the out-of-plane angle between 4 atoms

    input:
    atoms: tuple containing 4 numbers representing atoms
    molecule: a tuple generated from the readData function
    distanceMatrix: a matrix holding the interatomic distances

    output:
    the out-of-plan-angle between the atoms

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    if distanceMatrix[atoms[0]][atoms[3]] >= 4 or  distanceMatrix[atoms[1]][atoms[3]] >= 4 or distanceMatrix[atoms[2]][atoms[3]] >= 4:
        return "too far"
    # define part by part, for clarity
    cross_product = np.cross(UnitVectorCalculator(atoms[3], atoms[1], molecule), UnitVectorCalculator(atoms[3], atoms[2], molecule))
     
    dot_product = np.dot(cross_product, UnitVectorCalculator(atoms[3], atoms[0], molecule))

    bond_angle = angleCalculator((atoms[1], atoms[3], atoms[2]), molecule)

    return np.arcsin(dot_product/np.sin(bond_angle))


from itertools import permutations
def allOopAngles(molecule):
    """
    Calculates all oop angles for a given molecule

    input:
    molecule: a tuple as generated by the readData function
    distanceMatrix: a matrix holding the interatomic distances

    output:
    a dictionary containing all relevant oop angles (degrees)
    """
    atoms = np.arange(len(molecule[0]))
    perm = permutations(atoms, 4)
    angles_dict = {}
    for permutation in perm:
        angle = oopAnglesCalc(permutation, molecule)
        if angle != "too far":
            # because oop angles fulfill a symmetry
            if (permutation[0], permutation[2], permutation[1], permutation[3]) not in angles_dict:
                angles_dict[permutation] = angle*180/np.pi
    return angles_dict


def torsionAngleCalc(atoms, molecule):
    """ 
    Calculates the torsional angle between 4 atoms

    input:
    atoms: a tuple of numbers representing atoms
    molecule: a tuple as generated by the dataReader function
    distanceMatrix: a matrix that holds the interatomic distances

    output:
    the torsion angle

    note:
    the distanceMatrix is a global variable. It needs to be set before the function can be used
    """
    if distanceMatrix[atoms[0]][atoms[1]] >= 4 or  distanceMatrix[atoms[1]][atoms[2]] >= 4 or distanceMatrix[atoms[2]][atoms[3]] >= 4:
        return "too far"
    # define part by part, for clarity
    cross_product1 = np.cross(UnitVectorCalculator(atoms[0], atoms[1], molecule), UnitVectorCalculator(atoms[1], atoms[2], molecule))
     
    cross_product2 = np.cross(UnitVectorCalculator(atoms[1], atoms[2], molecule), UnitVectorCalculator(atoms[2], atoms[3], molecule))

    bond_angle1 = angleCalculator(atoms[:-1], molecule)

    bond_angle2 = angleCalculator(atoms[1:], molecule)
    # we need to limit the amount of decimals here
    torsion_angle = np.arccos(np.around(np.dot(cross_product1, cross_product2)/(np.sin(bond_angle1)*np.sin(bond_angle2)), 4))
    return torsion_angle


def allTorsionAnlges(molecule):
    """
    Calculates all the torsion angles in a given molecule

    input:
    molecule: a tuple as generated in the dataReader function
    distanceMatrix: a matrix the interatomic distances

    output:
    a dictionary containing all torsion angles (degrees)
    """
    atoms = np.arange(len(molecule[0]))
    combs = combinations(atoms, 4)
    angles_dict = {}
    for combination in combs:
        angle = torsionAngleCalc(combination, molecule)
        if angle != "too far":
            angles_dict[combination] = angle*180/np.pi
    return angles_dict


atomicmass_dict = {8:15.994, 6:12.0107, 1:1.0079}
def centerOfMassDeterminator(molecule):
    """
    Calculates the position of the center of mass

    input:
    molecule: tuple as generated by the readData function

    output:
    the position of the center of mass
    """
    atomic_weight = np.array([atomicmass_dict[atom] for atom in molecule[0]])
    multiplied_coords = atomic_weight*molecule[1].T
    return np.sum(multiplied_coords, axis =1)/np.sum(atomic_weight)


def tensorCalculator(molecule):
    """
    calculates the moment of inertia tensor for the given molecule

    input:
    molecule: a tuple as generated by the readData function

    output:
    the moment of inertia tensor
    """
    atomicmass_dict = {8:15.994, 6:12.0107, 1:1.0079}
    atomic_weigth = np.array([atomicmass_dict[atom] for atom in molecule[0]])
    molecule_center_distance = molecule[1] - centerOfMassDeterminator(molecule)
    R_values = np.linalg.norm(molecule_center_distance, axis=1)
    
    # initiate matrix
    
    inertia_tensor = np.zeros((3,3))
    
    # Since we will always work in 3D space, this nested loop will not become ineficcient with larger data 
    for i in range(3):
        for j in range(3):
            if i != j:
                inertia_tensor[i, j] += np.sum(atomic_weigth*(molecule_center_distance[:, i]*molecule_center_distance[:, j]))
            else:
                work_with = np.delete(molecule_center_distance, i, axis=1)
                inertia_tensor[i, i] += np.sum(atomic_weigth*work_with.T**2)

    return inertia_tensor


